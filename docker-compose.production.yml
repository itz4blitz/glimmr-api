name: glimmr-production

services:
  # =============================================================================
  # DATABASE LAYER (PRODUCTION)
  # =============================================================================
  postgres:
    image: postgres:16-alpine
    container_name: glimmr-postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: glimmr
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_INITDB_ARGS: "--auth-host=scram-sha-256"
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./tools/scripts/init-db-security.sql:/docker-entrypoint-initdb.d/init-security.sql:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d glimmr"]
      interval: 10s
      timeout: 5s
      retries: 5
    security_opt:
      - no-new-privileges:true

  # =============================================================================
  # CACHE LAYER (PRODUCTION)
  # =============================================================================
  redis:
    image: redis:7-alpine
    container_name: glimmr-redis
    restart: unless-stopped
    command: redis-server --requirepass ${REDIS_PASSWORD} --appendonly yes --maxmemory 512mb --maxmemory-policy allkeys-lru
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "--no-auth-warning", "-a", "${REDIS_PASSWORD}", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    security_opt:
      - no-new-privileges:true

  # =============================================================================
  # STORAGE LAYER (PRODUCTION)
  # =============================================================================
  minio:
    image: minio/minio:latest
    container_name: glimmr-minio
    restart: unless-stopped
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER:-glimmr-prod}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
      MINIO_BROWSER_REDIRECT_URL: https://minio.${DOMAIN:-glimmr.health}
    ports:
      - "9000:9000"  # API port
      - "9001:9001"  # Console port
    volumes:
      - minio_data:/data
    command: server /data --console-address ":9001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3
    security_opt:
      - no-new-privileges:true

  # =============================================================================
  # STORAGE SETUP (PRODUCTION)
  # =============================================================================
  minio-setup:
    image: minio/mc:latest
    container_name: glimmr-minio-setup
    depends_on:
      minio:
        condition: service_healthy
    entrypoint: >
      /bin/sh -c "
      mc alias set myminio http://minio:9000 ${MINIO_ROOT_USER:-glimmr-prod} $${MINIO_ROOT_PASSWORD};
      mc mb myminio/glimmr-prod --ignore-existing;
      mc policy set download myminio/glimmr-prod;
      echo 'Production MinIO setup complete';
      "
    security_opt:
      - no-new-privileges:true

  # =============================================================================
  # AUTHENTICATION (PRODUCTION)
  # =============================================================================
  authentik-postgres:
    image: postgres:16-alpine
    container_name: glimmr-authentik-postgres
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -d $${POSTGRES_DB} -U $${POSTGRES_USER}"]
      start_period: 20s
      interval: 30s
      retries: 5
      timeout: 5s
    volumes:
      - authentik_database:/var/lib/postgresql/data
    environment:
      POSTGRES_PASSWORD: ${AUTHENTIK_POSTGRES_PASSWORD}
      POSTGRES_USER: authentik
      POSTGRES_DB: authentik
    security_opt:
      - no-new-privileges:true

  authentik-redis:
    image: redis:alpine
    container_name: glimmr-authentik-redis
    command: --save 60 1 --loglevel warning --requirepass ${AUTHENTIK_REDIS_PASSWORD}
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "redis-cli --no-auth-warning -a ${AUTHENTIK_REDIS_PASSWORD} ping | grep PONG"]
      start_period: 20s
      interval: 30s
      retries: 5
      timeout: 3s
    volumes:
      - authentik_redis:/data
    security_opt:
      - no-new-privileges:true

  authentik-server:
    image: ghcr.io/goauthentik/server:2024.2.2
    container_name: glimmr-authentik-server
    restart: unless-stopped
    command: server
    environment:
      AUTHENTIK_REDIS__HOST: authentik-redis
      AUTHENTIK_REDIS__PASSWORD: ${AUTHENTIK_REDIS_PASSWORD}
      AUTHENTIK_POSTGRESQL__HOST: authentik-postgres
      AUTHENTIK_POSTGRESQL__USER: authentik
      AUTHENTIK_POSTGRESQL__NAME: authentik
      AUTHENTIK_POSTGRESQL__PASSWORD: ${AUTHENTIK_POSTGRES_PASSWORD}
      AUTHENTIK_SECRET_KEY: ${AUTHENTIK_SECRET_KEY}
      AUTHENTIK_ERROR_REPORTING__ENABLED: true
      AUTHENTIK_LOG_LEVEL: info
    volumes:
      - authentik_media:/media
      - authentik_custom_templates:/templates
    ports:
      - "9002:9000"  # Web UI
      - "9443:9443"  # HTTPS
    depends_on:
      - authentik-postgres
      - authentik-redis
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:9000/-/health/live/"]
      interval: 30s
      timeout: 10s
      retries: 5
    security_opt:
      - no-new-privileges:true

  authentik-worker:
    image: ghcr.io/goauthentik/server:2024.2.2
    container_name: glimmr-authentik-worker
    restart: unless-stopped
    command: worker
    environment:
      AUTHENTIK_REDIS__HOST: authentik-redis
      AUTHENTIK_REDIS__PASSWORD: ${AUTHENTIK_REDIS_PASSWORD}
      AUTHENTIK_POSTGRESQL__HOST: authentik-postgres
      AUTHENTIK_POSTGRESQL__USER: authentik
      AUTHENTIK_POSTGRESQL__NAME: authentik
      AUTHENTIK_POSTGRESQL__PASSWORD: ${AUTHENTIK_POSTGRES_PASSWORD}
      AUTHENTIK_SECRET_KEY: ${AUTHENTIK_SECRET_KEY}
      AUTHENTIK_LOG_LEVEL: info
    user: root
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - authentik_media:/media
      - authentik_certs:/certs
      - authentik_custom_templates:/templates
    depends_on:
      - authentik-postgres
      - authentik-redis
    healthcheck:
      test: ["CMD-SHELL", "celery -A authentik.root.celery inspect ping -d celery@$${HOSTNAME}"]
      interval: 30s
      timeout: 10s
      retries: 5
    security_opt:
      - no-new-privileges:true

  # =============================================================================
  # GLIMMR APPLICATION (PRODUCTION)
  # =============================================================================
  api:
    build:
      context: .
      dockerfile: apps/api/Dockerfile
      target: production
    container_name: glimmr-api
    restart: unless-stopped
    environment:
      NODE_ENV: production
      DATABASE_HOST: postgres
      DATABASE_PORT: 5432
      DATABASE_NAME: glimmr
      DATABASE_USERNAME: glimmr_api_user
      DATABASE_PASSWORD: ${GLIMMR_API_PASSWORD}
      DATABASE_SSL: true
      DATABASE_URL: postgresql://glimmr_api_user:${GLIMMR_API_PASSWORD}@postgres:5432/glimmr?sslmode=require
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD}
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379/0
      STORAGE_SPACES_ENDPOINT: http://minio:9000
      STORAGE_SPACES_BUCKET: glimmr-prod
      STORAGE_SPACES_ACCESS_KEY: ${MINIO_ROOT_USER:-glimmr-prod}
      STORAGE_SPACES_SECRET_KEY: ${MINIO_ROOT_PASSWORD}
      JWT_SECRET: ${JWT_SECRET}
      JWT_EXPIRES_IN: 24h
      CORS_ORIGINS: https://app.${DOMAIN:-glimmr.health},https://api.${DOMAIN:-glimmr.health}
      BCRYPT_ROUNDS: 12
      RATE_LIMIT_WINDOW_MS: 900000
      RATE_LIMIT_MAX_REQUESTS: 100
      LOG_LEVEL: info
      SENTRY_DSN: ${SENTRY_DSN}
    ports:
      - "3000:3000"
    volumes:
      - api_logs:/app/logs
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      minio:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/v1/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - SETGID
      - SETUID

  # =============================================================================
  # WEB APPLICATION (PRODUCTION)
  # =============================================================================
  web:
    build:
      context: .
      dockerfile: apps/web/Dockerfile
      target: production
    container_name: glimmr-web
    restart: unless-stopped
    environment:
      NODE_ENV: production
      VITE_API_URL: https://api.${DOMAIN:-glimmr.health}/api/v1
      VITE_WS_URL: wss://api.${DOMAIN:-glimmr.health}
    ports:
      - "5174:80"
    depends_on:
      - api
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:80"]
      interval: 30s
      timeout: 10s
      retries: 3
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL

  # =============================================================================
  # DATA PROCESSING (PRODUCTION)
  # =============================================================================
  airflow-postgres:
    image: postgres:16-alpine
    container_name: glimmr-airflow-postgres
    restart: unless-stopped
    environment:
      POSTGRES_USER: airflow
      POSTGRES_PASSWORD: ${AIRFLOW_POSTGRES_PASSWORD}
      POSTGRES_DB: airflow
    volumes:
      - airflow_postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U airflow -d airflow"]
      interval: 10s
      timeout: 5s
      retries: 5
    security_opt:
      - no-new-privileges:true

  airflow-webserver:
    image: apache/airflow:2.8.1-python3.11
    container_name: glimmr-airflow-webserver
    restart: unless-stopped
    environment:
      AIRFLOW__CORE__EXECUTOR: LocalExecutor
      AIRFLOW__DATABASE__SQL_ALCHEMY_CONN: postgresql+psycopg2://airflow:${AIRFLOW_POSTGRES_PASSWORD}@airflow-postgres:5432/airflow
      AIRFLOW__CORE__FERNET_KEY: ${AIRFLOW_FERNET_KEY}
      AIRFLOW__CORE__DAGS_ARE_PAUSED_AT_CREATION: "true"
      AIRFLOW__CORE__LOAD_EXAMPLES: "false"
      AIRFLOW__API__AUTH_BACKENDS: airflow.api.auth.backend.basic_auth
      AIRFLOW__SCHEDULER__ENABLE_HEALTH_CHECK: "true"
      AIRFLOW__WEBSERVER__EXPOSE_CONFIG: "false"
      AIRFLOW__WEBSERVER__RBAC: "true"
      _AIRFLOW_WWW_USER_USERNAME: admin
      _AIRFLOW_WWW_USER_PASSWORD: ${AIRFLOW_ADMIN_PASSWORD}
    depends_on:
      airflow-postgres:
        condition: service_healthy
    volumes:
      - ./infrastructure/airflow/dags:/opt/airflow/dags:ro
      - airflow_logs:/opt/airflow/logs
    ports:
      - "8081:8080"
    command: webserver
    healthcheck:
      test: ["CMD", "curl", "--fail", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 5
    security_opt:
      - no-new-privileges:true

  airflow-scheduler:
    image: apache/airflow:2.8.1-python3.11
    container_name: glimmr-airflow-scheduler
    restart: unless-stopped
    environment:
      AIRFLOW__CORE__EXECUTOR: LocalExecutor
      AIRFLOW__DATABASE__SQL_ALCHEMY_CONN: postgresql+psycopg2://airflow:${AIRFLOW_POSTGRES_PASSWORD}@airflow-postgres:5432/airflow
      AIRFLOW__CORE__FERNET_KEY: ${AIRFLOW_FERNET_KEY}
      AIRFLOW__CORE__DAGS_ARE_PAUSED_AT_CREATION: "true"
      AIRFLOW__CORE__LOAD_EXAMPLES: "false"
    depends_on:
      airflow-postgres:
        condition: service_healthy
    volumes:
      - ./infrastructure/airflow/dags:/opt/airflow/dags:ro
      - airflow_logs:/opt/airflow/logs
    command: scheduler
    healthcheck:
      test: ["CMD", "airflow", "jobs", "check", "--job-type", "SchedulerJob", "--hostname", "$${HOSTNAME}"]
      interval: 30s
      timeout: 10s
      retries: 5
    security_opt:
      - no-new-privileges:true

  # =============================================================================
  # CLOUDFLARE TUNNEL (PRODUCTION)
  # =============================================================================
  cloudflare-tunnel:
    image: cloudflare/cloudflared:latest
    container_name: glimmr-cloudflare-tunnel
    restart: unless-stopped
    command: tunnel --no-autoupdate run --token ${CLOUDFLARE_TUNNEL_TOKEN}
    environment:
      TUNNEL_TOKEN: ${CLOUDFLARE_TUNNEL_TOKEN}
    depends_on:
      - api
      - web
      - authentik-server
      - airflow-webserver
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL

volumes:
  postgres_data:
  redis_data:
  minio_data:
  authentik_database:
  authentik_redis:
  authentik_media:
  authentik_certs:
  authentik_custom_templates:
  airflow_postgres_data:
  airflow_logs:
  api_logs: